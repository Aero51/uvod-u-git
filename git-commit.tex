\chapter*{Spremanje izmjena}
\addcontentsline{toc}{chapter}{Spremanje izmjena}

Vratimo se na trenutak na naša dva primjera, linerani model verzioniranja koda:

\input{graphs/linearni_model}

\dots{}i primjer s granama:

\input{graphs/primjer_s_granama_i_spajanjima}

U oba slučaja, čvorovi tih grafova su stanje projekta u nekom trenutku.
Na primjer, kad ste prvi put inicirali projekt s \verb+git init+, dodali ste nekoliko datoteka i \emph{spremili ih}. 
U tom trenutku je nastao čvor \emph a.
Nakon toga ste možda izmijenili neke od tih datoteka, možda neke obrisali, neke nove dodali i opet -- spremili novo stanje i dobili stanje \emph b.

To što ste radili između svaka dva stanja je vaša stvar.
No, trenutak kad se odlučite spremiti novo stanje projekta u vaš repozitorij -- to je gitu jedino važno i to se zove \emph{commit}.

Važno je ovdje napomenuti da u gitu, za razliku od subversiona, CVS-a ili TFS-a \emph{nikad ne commitate u udaljeni repozitorij}. 
Svoje lokalne promjene \emph{commit}ate, odnosno \emph{spremate} u \emph{lokalni} repozitorij na vašem računalu.
Interakcija s udaljenim repozitorijem će biti tema poglavlja o udaljenim repozitorijima.

\section*{Status}
\addcontentsline{toc}{section}{Status}

Da biste provjerili imate li uopće nešto za spremati, koristi se naredba \verb+git status+.
Na primjer, kad na projektu koji nema lokalnih izmjena za spremanje utipkate \verb+git status+, dobiti ćete:

\input{git_output/git_status_0}

Pretpostavimo da ste odlučili napraviti tri izmjene na projektu.
Izmijenili ste liniju u datoteci \verb+README.md+ i \verb+setup.py+ i obrisali \verb+TODO.txt+:
Sad će rezultat od \verb+git status+ izgledati ovako:

\input{git_output/git_status_1}

Najbitniji podatak je linija u kojoj piše \verb+modified: git-commit.tex+, jer to je datoteka koju smo \emph{mijenjali}, ali ne još \emph{commit}ali.

Želite li pogledati \emph{koje su točne razlike} u tim datotekama u odnosu na stanje kakvo je snimljeno u repozitoriju, odnosno u \emph{zadnjoj verziji} repozitorija, to ćete dobiti s \verb+git diff+. 
Primjer jednog ispisa te naredbe je:

\input{git_output/git_diff_1}

Ako vam ovo izgleda zbunjujuće -- postoji i način kako da se to ljepše prikaže, no, čisto za vježbu, nije loše pokušati interpretirati što ovo znači.
Najvažniji dijelovi su linije oni koji počinju si \verb+diff+, jer one govore o kojim datotekama se radi.
Nakon njih slijedi nekoliko linija s općenitim podacima i zatim kod \emph{oko} dijela koji je izmijenjen i onda ono najvažnije -- linije obojane u crveno i one obojane u plavo.

Linije koje započinju s "-" (crvene) su linije koje su \emph{obrisane}, a one koje počinju s "+" (u plavom) su one koje su \emph{dodane}. 
Primijetimo da git ne zna da ste neku liniju izmijenili. 
Ukoliko jesmo -- on se ponaša kao da smo staru obrisalu, a novu dodali.

Rezultat git naredbe su samo dijelovi koje ste izmijenili i nekoliko linija \emph{oko njih}.
Ukoliko želimo malo veću tu "okolinu" oko naših izmjena, možemo ju izmijeniti s opcijom \\ \verb+-U<broj_linija>+.
Na primjer, ukoliko želimo $10$ linija oko izmjenjenih dijelova koda, to ćemo dobiti sa:

\gitoutputcommand{git diff -U10}

\section*{Indeks}
\addcontentsline{toc}{section}{Indeks}

U gitu postoji poseban "međuprostor" u koje se "stavljaju" datoteke koje ćemo spremiti (\emph{commit}ati).
Svaka stanje neke datoteke se može nalaziti u tri različita stanja:

\begin{itemize}
	\item datoteka je već spremljena negdje u git repozitoriju,
	\item datoteku smo tek izmijenili i nismo ju još \emph{commit}ali u repozitorij,
	\item datoteku smo stavili u taj "međuprostor" tako da bismo se pripremili za \emph{commit}.
\end{itemize}

Ovo zadnje stanje, odnosno, taj "međuprostor za \emph{commit}" se zove \emph{index} iliti indeks.
U literaturi ćete često naći i naziv \emph{staging area} ili \emph{cache}\footnote{Nažalost, git ovdje nije konzistentan pa i u svojoj dokumentaciji ponekad koristi \emph{stage}, a ponekad \emph{cache}.}.
I naredba \verb+git status+ je upravo namijenjena pregledavanju statusa indeksa.
Na primjer, u trenutku pisanja ovog poglavlja, \verb+git status+ je\footnote{Da, i ova knjiga je pisana koristeći git. Detalji na https://github.com/tkrajina/uvod-u-git}:

\input{git_output/git_status_prije_indeksa}

Ovaj ispis govori kako je jedna datoteka izmijenjena, ali nije još \emph{commit}ana niti stavljena u indeks.

\subsection*{Spremanje u indeks}
\addcontentsline{toc}{subsection}{Spremanje u indeks}

Datoteku možemo staviti u indeks s:

\gitoutputcommand{git add git-commit.tex}

\dots{}i sad je status:

\input{git_output/git_status_nakon_indeksa}

Primijetiti ćete dio u kojem piše, \texttt{Changes to be committed} -- e to je spisak datoteka koje ste stavili u indeks.

Čak i ako smo datoteku \emph{obrisali} -- moramo ju dodati u indeks naredbom \verb+git add+.
Ako vas to zbunjuje -- zamislite to kao da \textbf{u indeks ne stavljate u stvari datoteku nego neko njeno (izmijenjeno) stanje}.
Kad ste datoteku obrisali -- u indeks treba spremiti novo stanje te datoteke ("izbrisano stanje").

\subsection*{Micanje iz indeksa}
\addcontentsline{toc}{subsection}{Micanje iz indeksa}

Ako smo neku datoteku stavili u indeks i kasnije se predomislili. 
Sad tu datoteku želimo izbaciti iz indeksa, ali bez da gubimo izmjene koje smo na njoj napravili jer će one biti dio nekog sljedećeg \emph{commit}a.
Ili ih jednostavno ne želimo u povijesti projekta (i datoteku ćemo resetirati na prethodno stanje).
To se može naredbom:

\gitoutputcommand{git reset HEAD -- <datoteka1> <datoteka2> \dots}

Nakon toga, izmjene treba \emph{commit}ati.

Događati će nam se da smo promijenili neku datoteku, no kasnije se ispostavilo da ta izmjena nije bila potrebna. 
I sad ju ne želite spremiti nego vratiti u prethodno stanje.
To se može ovako:

\gitoutputcommand{git checkout HEAD -- <datoteka1> <datoteka2> \dots}

Više detalja o \verb+git checkout+ i zašto ta gornja naredba radi to što radi će biti kasnije.

\subsection*{O indeksu i stanju datoteka}
\addcontentsline{toc}{subsection}{O indeksu i stanju datoteka}

Ima još jedan detalj koji bi vas mogao zbuniti. 
Uzmimo situaciju da samo jednu datoteku izmijenili i spremili u indeks:

\input{git_output/git_status_nakon_indeksa}

No, sad tu datoteku još jednom izmijenimo. 
Sad je stanje ovakvo:

\input{git_output/git_status_nakon_indeksa_2}

Sad tu datoteku imamo izmijenjenu i u radnoj verziji (direktorij kakav je trenutno na disku) i u indeksu.
Ako vas to zbunjuje, upamtite: Indeks (i git općenito) ne sprema datoteke nego \textbf{stanja datoteka}.
I, u tom smislu, nije ništa neobično da imamo jedno stanje datoteke u indeksu, a drugo stanje datoteke u radnoj verziji našeg projekta.

Ukoliko sad želimo osvježiti indeks sa zadnjom verzijom datoteke (onu koja je, \emph{de facto} spremljena u direktoriju), onda ćemo jednostavno:

\gitoutputcommand{git add $<$datoteka$>$}

Dakle, ukratko, indeks je prostor u kojeg spremamo grupu datoteka (odnosno \textbf{stanja} datoteka).
Takav skup datoteka treba predstavljati neku logičku cjelinu tako da bi ih mogli spremiti u repozitorij.
To spremanje je jedan \emph{commit}, a tim postupkom smo grafu našeg repozitorija dodali još jedan čvor. 

Prije \emph{commit}a datoteke možemo stavljati u indeks ili izbacivati iz indeksa.
Sve dok nismo sigurni da indeks predstavlja točno one datoteke koje želimo u našoj izmjeni (\emph{commit}u).

Razlika između tog, novog, čvora i njegovog prethodnika su upravo datoteke koje smo imali u indeksu u trenutku kad smo \emph{commit} izvršili.

\section*{Prvi commit}
\addcontentsline{toc}{section}{Prvi commit}

Izmjene možete spremiti s:

\gitoutputcommand{git commit -m "Nova verzija"}

U stringu nakon \verb+-m+ \emph{morate} unijeti komentar uz svaku promjenu koju spremate na projektu.
Git ne dopušta spremanje izmjena bez komentara.

Sad je status projekta opet:

\input{git_output/git_status_0}

Kad smo napravili izmjene na projektu, a \emph{nismo} ih još snimili, graf projekta izgleda ovako nekako:

\input{graphs/linearni_bez_zadnjeg_cvora}

Dakle, zadnji čvor nema "nasljednika".
Tek kad napravite taj zadnji \emph{commit} vaše izmjene postaju dio repozitorija i tada je graf:

\input{graphs/linearni_sa_zadnjim_cvorom}

\subsection*{Datoteke koje želimo u repozitoriju}
\addcontentsline{toc}{subsection}{Datoteke koje ne želimo u repozitoriju}

Jedan scenarij koji se često događa je sljedeći:
Greškom smo u repozitorij spremili datoteku koja tamo ne treba biti. 
Međutim, tu datoteku ne želimo obrisati s našeg diska, nego samo ne želimo njenu povijest imati u repozitoriju.

To je, na primjer, situacija kad nam editor ili IDE spremi konfiguracijske datoteke koje su njemu važne, ali nisu bitne za projekt.
Eclipse tako zna snimiti \verb+.project+, a Vim sprema radne datoteke s ekstenzijama \verb+.swp+ ili \verb+.swo+.
Ako smo takvu datoteku jednom dodali u repozitorij, a naknadno smo zaključili da ju više ne želimo, onda ju prvo trebamo dodati u \verb+.gitignore+.
Nakon toga -- git zna da \textbf{ubuduće} neće biti potrebno snimati izmjene na njoj.

No, ona je i dalje u repozitoriju!
Ne želimo ju obrisati s diska, ali ne želimo ju ni u povijesti projekta.
Neka je to, na primjer, \verb+test.pyc+.
Postupak je:

\gitoutputcommand{git rm --cached test.pyc}

To će vam u indeks dodati kao da je datoteka obrisana, iako ju ostavlja netaknutu na disku.
Sad tu izmjenu treba \emph{commit}ati

Budući da smo datoteku prethodno dodali u \verb+.gitignore+, git nam ubuduće nuditi da ju \emph{commit}amo.

\section*{Povijest projeka}
\addcontentsline{toc}{section}{Povijest projeka}

\dots{}a sve prethodne izmjene možete pogledati s \verb+git log+:

\input{git_output/git_log_0}

Više o tome u posebnom poglavlju. 
Za sada je važno znati da u gitu svaki \emph{commit} ima jedinstveni string koji ga identificira.
Taj string ima 40 znamenaka i primjere možemo vidjeti u rezultatu od \verb+git log+.
Na primjer, \verb+bf4fc495fc926050fb10260a6a9ae66c96aaf908+ je jedan takav.

\section*{Ispravljanje zadnje izmjene}
\addcontentsline{toc}{section}{Ispravljanje zadnje izmjene}

Dogoditi će vam se da spremite neku izmjenu u repozitorij, a nakon toga proučavate još malo projekt i shvatite da ste mogli još jednu sitnicu ispraviti.
I, nekako vam se čini da bi bilo logično da ta sitnica bude dio prethodnog \emph{commit}a.
Bilo bi lijepo, pomislit' ćete kad biste mogli izmijeniti zadnji \emph{commit} tako da sadrži i ovu novu, sitnu, ispravku koju biste dodali.

S gitom se to može.
Prvo učinomo tu izmjenu; recimo da je ona bila na datoteci \verb+README.md+, dodate tu datoteku u indeks s \verb+git add README.md+ i izvršite sljedeće:

\gitoutputcommand{git commit --amend -m "Nova verzija, promijenjen README.md"}

Ovaj \verb+--amend+ gitu naređuje da promijeni zadnji \emph{commit} u povijesti tako da sadrži izmjene koje je imao i izmjene koje smo upravo dodali.
Možemo provjeriti s \verb+git log+ šte se desilo i vidjeti ćemo da zadnji \emph{commit} sad ima novi komentar.
U stvari, ispravno bi bilo kazati da je promijenjen i cijeli taj \emph{commit}.

\verb+git commit --amend+ nam omogućava da u zadnji \emph{commit} dodamo neku datoteku ili čak i \emph{maknemo} datoteku koju smo prethodno \emph{commit}ali. 
No, treba samo pripaziti da se taj commit nalazi samo na našem lokalnom repozitoriju, a ne i na nekom od udaljenih. 
O tome više malo kasnije.

\section*{Git gui}
\addcontentsline{toc}{section}{Git gui}

Kad spremamo neku izmjenu koja ima puno datoteka, onda može postati naporno non-stop tipkati \verb+git add+.
Zbog toga postoji poseban grafički program kojemu je glavna namjena upravo to.
U komandnoj liniji:

\gitoutputcommand{git gui}

Otvoriti će se sljedeće:

\gitgraphics{images/git-gui.png}

Program se sastoji od četiri polja. 

\begin{itemize}
	\item Polje za datoteke koje su izmijenjene, ali nisu još u indeksu (gore lijevo).
	\item Polje za prikaz izmjena u pojedinim datotekama (gore desno). 
	\item Polje za datoteke koje su izmijenjene i stavljene su u indeks (dolje lijevo).
	\item Polje za \emph{commit} (dolje lijevo).
\end{itemize}

Klik na neku datoteku će prikazati sve izmjene koja ta datoteka sadrži u odnosu na zadnje snimljeno stanje u repozitoriju.
Format je isti kao i kod \verb+git diff+.
Klik na ikonu uz naziv datoteke će istu prebaciti iz polja izmijenjenih datotka u polje s indeksom i suprotno.
Nakon što odaberemo datoteke za koje želimo da budu dio našeg \emph{commit}a, trebamo unijeti komentar i kliknuti na "Commit" za snimanje izmjene.

Ovdje, kao i u radu s komandnom linijom ne moramo sve izmijenjene datoteke snimiti u jednom \emph{commit}u. 
Možemo dodati nekoliko datoteka, upisati komentar, snimiti i nakon toga dodati sljedećih nekoliko datoteka, opisati novi komentar i snimiti sljedeću izmjenu.
Drugim riječima, izmjene možete snimiti u nekoliko posebnih \emph{commit}ova, tako da svaki od njih čini zasebnu logičku cjelinu.

S \verb+git gui+ imamo još jednu korisnu opciju -- možemo u indeks dodati \textbf{ne cijelu datoteku, nego samo nekoliko izmijenjenih linija} datoteke.
Za tu datoteku, u polju s izmijenjenim linijama odaberimo samo linije koje želimo spremite, desni klik i:

\gitgraphics{images/git-gui-stage-lines-to-commit.png}

Ako smo na nekoj datoteci napravili izmjenu koju \emph{ne} želimo snimiti -- takvu datoteku možemo resetirati, odnosno vratiti u početno stanje. 
Jednostavno odaberemo ju u meniju \verb+Commit+ $\rightarrow$ \verb+Revert changes+.

Osim ovoga, \verb+git gui+ ima puno korisnih mogućnosti koje nisu predmet ovog poglavlja.
Preporučam van da nađete vremena i proučite sve menije i kratice s tastaturom u radu, jer to će vam značajno ubrzati rad s ovim korisnim programčićem.

%\begin{itemize}
%   \item Tipični scenarij
%   \item Stash?
%   \item Pointeri na commit (hash, HEAD, HEAD~1, HEAD~2, ... master~1, master~2, master~3 )
%   \item Brisanje fajla iz repozitrija (ali ne i lokalnog filesystema)
%   \item Logoff objasniti
%\end{itemize}

%\section*{}
%\addcontentsline{toc}{section}{}

