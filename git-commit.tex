\chapter*{Spremanje izmjena}
\addcontentsline{toc}{chapter}{Spremanje izmjena}

Vratimo se na trenutak na naša dva primjera, linerani model verzioniranja koda:

\input{graphs/linearni_model}

\dots{}i primjer s granama:

\input{graphs/primjer_s_granama_i_spajanjima}

U oba slučaja, čvorovi tih grafova su stanje projekta u nekom trenutku.
Na primjer, kad ste prvi put inicirali projekt s \verb+git init+, dodali ste nekoliko datoteka i \emph{spremili ih}. 
U tom trenutku je nastao čvor \emph a.
Nakon toga ste možda izmijenili neke od tih datoteka, možda neke obrisali, neke nove dodali i opet -- spremili novo stanje i dobili stanje \emph b.

To što ste radili između svaka dva stanja je vaša stvar.
No, trenutak kad se odlučite spremiti novo stanje projekta u vaš repozitorij -- to je gitu jedino važno i to se zove \emph{commit}.

Važno je ovdje napomenuti da u gitu, za razliku od subversiona, CVS-a ili TFS-a \emph{nikad ne commitate u udaljeni repozitorij}. 
Svoje lokalne promjene \emph{commit}ate, odnosno \emph{spremate} u \emph{lokalni} repozitorij na vašem računalu.
Interakcija s udaljenim repozitorijem će biti tema poglavlja o udaljenim repozitorijima.

\section*{Status}
\addcontentsline{toc}{section}{Status}

Da biste provjerili imate li uopće nešto za spremati, koristi se naredba \verb+git status+.
Na primjer, kad na projektu koji nema lokalnih izmjena za spremanje utipkate \verb+git status+, dobiti ćete:

\input{git_output/git_status_0}

Pretpostavimo da ste odlučili napraviti tri izmjene na projektu.
Izmijenili ste liniju u datoteci \verb+README.md+ i \verb+setup.py+ i obrisali \verb+TODO.txt+:
Sad će rezultat od \verb+git status+ izgledati ovako:

\input{git_output/git_status_1}

Najbitniji podatak je linija u kojoj piše \verb+modified: git-commit.tex+, jer to je datoteka koju smo \emph{mijenjali}, ali ne još \emph{commit}ali.

Želite li pogledati \emph{koje su točne razlike} u tim datotekama u odnosu na stanje kakvo je snimljeno u repozitoriju, odnosno u \emph{zadnjoj verziji} repozitorija, to ćete dobiti s \verb+git diff+. 
Primjer jednog ispisa te naredbe je:

\input{git_output/git_diff_1}

Ako vam ovo izgleda zbunjujuće -- postoji i način kako da se to ljepše prikaže, no, čisto za vježbu, nije loše pokušati interpretirati što ovo znači.
Najvažniji dijelovi su linije oni koji počinju si \verb+diff+, jer one govore o kojim datotekama se radi.
Nakon njih slijedi nekoliko linija s općenitim podacima i zatim kod \emph{oko} dijela koji je izmijenjen i onda ono najvažnije -- linije obojane u crveno i one obojane u plavo.

Linije koje započinju s "-" (crvene) su linije koje su \emph{obrisane}, a one koje počinju s "+" (u plavom) su one koje su \emph{dodane}. 
Primijetimo da git ne zna da ste neku liniju izmijenili. 
Ukoliko jesmo -- on se ponaša kao da smo staru obrisalu, a novu dodali.

Rezultat git naredbe su samo dijelovi koje ste izmijenili i nekoliko linija \emph{oko njih}.
Ukoliko želimo malo veću tu "okolinu" oko naših izmjena, možemo ju izmijeniti s opcijom \\ \verb+-U<broj_linija>+.
Na primjer, ukoliko želimo $10$ linija oko izmjenjenih dijelova koda, to ćemo dobiti sa:

\gitoutputcommand{git diff -U10}

\section*{Indeks}
\addcontentsline{toc}{section}{Indeks}

U gitu postoji poseban "međuprostor" u koje se "stavljaju" datoteke koje ćemo spremiti (\emph{commit}ati).
Svaka stanje neke datoteke se može nalaziti u tri različita stanja:

\begin{itemize}
	\item datoteka je već spremljena negdje u git repozitoriju,
	\item datoteku smo tek izmijenili i nismo ju još \emph{commit}ali u repozitorij,
	\item datoteku smo stavili u taj "međuprostor" tako da bismo se pripremili za \emph{commit}.
\end{itemize}

Ovo zadnje stanje, odnosno, taj "međuprostor za \emph{commit}" se zove \emph{index} iliti indeks.
U literaturi ćete često naći i naziv \emph{staging area} ili \emph{cache}\footnote{Nažalost, git ovdje nije konzistentan pa i u svojoj dokumentaciji ponekad koristi \emph{stage}, a ponekad \emph{cache}.}.
I naredba \verb+git status+ je upravo namijenjena pregledavanju statusa indeksa.
Na primjer, u trenutku pisanja ovog poglavlja, \verb+git status+ je\footnote{Da, i ova knjiga je pisana koristeći git. Detalji na https://github.com/tkrajina/uvod-u-git}:

\input{git_output/git_status_prije_indeksa}

Ovaj ispis govori kako je jedna datoteka izmijenjena, ali nije još \emph{commit}ana niti stavljena u indeks.
Idemo ju staviti u indeks s:

\gitoutputcommand{git add git-commit.tex}

\dots{}i sad je status:

\input{git_output/git_status_nakon_indeksa}

Primijetiti ćete dio u kojem piše, \texttt{Changes to be committed} -- e to je spisak datoteka koje ste stavili u indeks.

Čak i ako smo datoteku \emph{obrisali} -- moramo ju dodati u indeks naredbom \verb+git add+.
Ako vas to zbunjuje -- zamislite to kao da \textbf{u indeks ne stavljate u stvari datoteku nego neko njeno (izmijenjeno) stanje}.
Kad ste datoteku obrisali -- u indeks treba spremiti novo stanje te datoteke ("izbrisano stanje").

Dogoditi će se da smo neku datoteku stavili u indeks, ali smo se kasnije predomislili. 
Sad tu datoteku želimo izbaciti iz indeksa, ali bez da gubimo izmjene koje smo na njoj napravili jer će one biti dio nekog sljedećeg \emph{commit}a.
Ili ih jednostavno ne želimo u povijesti projekta (i datoteku ćemo resetirati na prethodno stanje).
To se može naredbom:

\gitoutputcommand{git reset HEAD -- <datoteka1> <datoteka2> \dots}

Nakon toga, izmjene treba \emph{commit}ati.

Još jedan scenarij koji se često događa je sljedeći:
Greškom ste u repozitorij spremili fajl koji tamo ne treba biti. 
Taj fajl ste sad dodali u \verb+.gitignore+, ali on je i dalje u repozitoriju. 
Ne želite ga obrisati, ali ne želite ga više u povijesti projekta.
Neka je to, na primjer, \verb+test.pyc+:

\gitoutputcommand{git rm --cached test.pyc}

To će vam u indeks dodati kao da je datoteka obrisana, iako ju ostavlja netaknutu na disku.
Budući da smo datoteku prethodno dodali u \verb+.gitignore+, git više neće nuditi da ju \emph{commit}amo.

Događati će nam se da smo promijenili neku datoteku, no kasnije se ispostavilo da ta izmjena nije bila potrebna. 
I sad ju ne želite spremiti nego vratiti u prethodno stanje.
To se može ovako:

\gitoutputcommand{git checkout HEAD -- <datoteka1> <datoteka2> \dots}

Više detalja o \verb+git checkout+ i zašto ova gornja naredba radi to što radi biti će u kasnije.

\TODO Slučaj kad je datoteka i u indeksu i izmijenjena

\section*{Prvi commit}
\addcontentsline{toc}{section}{Prvi commit}

Izmjene možete spremiti s:

\gitoutputcommand{git commit -m "Nova verzija"}

U stringu nakon \verb+-m+ \emph{morate} unijeti komentar uz svaku promjenu koju spremate na projektu.
Git ne dopušta spremanje izmjena bez komentara.

Sad je status projekta opet:

\input{git_output/git_status_0}

Kad ste napravili izmjene na projektu, a \emph{niste} ih još snimili, graf projekta izgleda ovako nekako:

\input{graphs/linearni_bez_zadnjeg_cvora}

Dakle, zadnji čvor nema "nasljednika".
Tek kad napravite taj zadnji commit vaše izmjene postaju dio repozitorija i tada je graf:

\input{graphs/linearni_sa_zadnjim_cvorom}

\section*{Povijest projeka}
\addcontentsline{toc}{section}{Povijest projeka}

\dots{}a sve prethodne izmjene možete pogledati s \verb+git log+:

\input{git_output/git_log_0}

Više o tome u posebnom poglavlju. 
Za sada upamtite samo da u gitu svaki \emph{commit} ima jedinstveni string koji ga identificira.
Taj string ima 40 znamenaka i primjere možete vidjeti u rezultatu od \verb+git log+.
Na primjer, \verb+bf4fc495fc926050fb10260a6a9ae66c96aaf908+ je jedan takav.

\section*{Ispravljanje zadnje izmjene}
\addcontentsline{toc}{section}{Ispravljanje zadnje izmjene}

Dogoditi će vam se da spremite neku izmjenu u repozitorij, gledate još malo projekt i shvatite da ste mogli još jednu sitnicu napraviti.
I, nekako vam se čini da bi bilo logično da ta sitnica bude dio prethodnog \emph{commit}a.

Bilo bi lijepo, pomislit' ćete kad biste mogli izmijeniti zadnji \emph{commit} tako da sadrži i ovu novu, sitnu, ispravku koju ste dodali.
S gitom se to može.
Prvo \emph{napravite} tu izmjenu; recimo da je ona bila na datotecu \verb+README.md+, dodate tu datoteku u indeks s \verb+git add README.md+ i izvršite sljedeće:

\gitoutputcommand{git commit --amend -m "Nova verzija, promijenjen README.md"}

Ukoliko provjerite s \verb+git log+ šte se desilo, otkriti ćete da zadnji \emph{commit} sad ima novi komentar.
U stvari, ispravno bi bilo kazati da je promijenjen i cijeli taj \emph{commit}.

\verb+git commit --amend+ vam omogućava da u zadnji commit dodate neku datoteku ili čak i \emph{maknete} datoteku koju ste prethodno \emph{commit}ali. 
No, treba samo pripaziti da se taj commit nalazi samo na vašem lokalnom repozitoriju, a ne i na nekom od udaljenih. 
O tome više malo kasnije.

\section*{Git gui}
\addcontentsline{toc}{section}{Git gui}

Kad spremate neku izmjenu koja ima puno datoteka, onda je gnjavaža non stop tipkati \verb+git add+.
Zbog toga postoji poseban grafički program kojemu je glavna namjena upravo to.
Kad u komandnoj liniji utipkate:

\gitoutputcommand{git gui}

Otvoriti će se sljedeće:

\includegraphics[width=14cm]{images/git-gui.png}

Program se sastoji od četiri polja. 

\begin{itemize}
	\item Polje za datoteke koje su izmijenjene, ali nisu još u međuprostoru za snimanje izmjena (gore lijevo).
	\item Polje za prikaz izmjena u pojedinim datotekama (gore desno). 
	\item Polje za datoteke koje su izmijenjene i stavljene su u međuprostor za \emph{commit} (dolje lijevo).
	\item Polje za \emph{commit} (dolje lijevo).
\end{itemize}

Kad kliknete na neku datoteku, prikazati će se sve izmjene koja ta datoteka sadrži u odnosu na zadnje snimljeno stanje u repozitoriju.
Format je isti kao i kod \verb+git diff+.
Klik na ikonu uz naziv datoteke će istu prebaciti iz polja izmijenjenih datotke u polje izmijenjenih i spremnih za \emph{commit} i suprotno.
Upišite komentar i kliknite na \emph{Commit} za snimanje izmjene.

Ovdje, kao i u radu s komandnom linijom ne morati sve izmijenjene datoteke snimiti u jednom \emph{commit}u. 
Možete dodati nekoliko datoteka, upisati komentar, snimiti i nakon toga dodati sljedećih nekoliko datoteka, opisati novi komentar i snimiti sljedeću izmjenu.
Drugim riječima, izmjene možete snimiti u nekoliko posebnih \emph{commit}ova, tako da svaki od njih čini zasebnu logičku cjelinu.
Koristite li \verb+git gui+ onda ovdje imati još jednu korisnu opciju, možete u indeks dodati ne \emph{cijelu} datoteku, nego samo \emph{nekoliko izmijenjenih linija}.
Odaberite datoteku, u polju s izmijenjenim linijama odaberite samo linije koje želite spremite, desni klik i:

\includegraphics[width=14cm]{images/git-gui-stage-lines-to-commit.png}

Više puta će vam se dogoditi da ste na nekoj datoteci napravili izmjenu koju \emph{ne} želite snimiti. 
Takvu datoteku možete resetirati, odnosno vratiti u početno stanje tako da ju odaberete u meniju \verb+Commit+ $\rightarrow$ \verb+Revert changes+.

Osim ovoga, \verb+git gui+ ima puno korisnih mogućnosti koje nisu predmet ovog poglavlja.
Preporučam van da nađete vremena i proučite sve menije i kratice s tastaturom u radu, jer to će vam drastično ubrzati rad s ovim korisnim programčićem.

%\begin{itemize}
%   \item Tipični scenarij
%   \item Stash?
%   \item Pointeri na commit (hash, HEAD, HEAD~1, HEAD~2, ... master~1, master~2, master~3 )
%   \item Brisanje fajla iz repozitrija (ali ne i lokalnog filesystema)
%   \item Logoff objasniti
%\end{itemize}

%\section*{}
%\addcontentsline{toc}{section}{}

