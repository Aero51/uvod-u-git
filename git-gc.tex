\chapter*{"Higijena" repozitorija}
\addcontentsline{toc}{chapter}{"Higijena" repozitorija}

Naš repozitorij je naš životni prostor i s njime živimo dio dana.
Kao što se trudimo držati stan urednim, tako bi trebalo i s našim virtualnim prostorima.
Preko tjedna, kad rano ujutro odlazimo na posao i vraćamo se kasnije popodne, se ponekad desi da nam se u stanu nagomila robe za pranje.
No, nekoliko puta tjedno treba uzeti pola sata vremena i počistiti nered koji je zaostao.

Tako i s repozitorijem.
Ima nekoliko stvari na koje bi trebali pripaziti.

\section*{Grane}
\addcontentsline{toc}{section}{Grane}

Nemojte si dopustiti da grane u vašem repozitoriju izgledaju ovako "zbrčkano":

\input{graphs/cirkus}

Iako nam git omogućuje da imamo neograničen broj grana, ljudski um nije sposoban vizualizirati si više od 5-10 njih\footnote{Barem moj nije, ako je vaš izuzetak, preskočite sljedećih nekoliko rečenica. Ili jednostavno zamislite da je umjesto "5-10" pisalo "500-1000".}.
Kako stvaramo nove grane -- dešava se da imamo one u kojima smo počeli neki posao i kasnije odlučili da nam ne treba.
Ili smo napravili posao, \emph{merge}ali u \verb+master+, ali nismo obrisali granu.
Nađemo li se s više od 10-15 grana -- \textbf{sigurno} je dio njih tu samo zato što smo ih zaboravili obrisati.

U svakom slučaju, predlažem vam da svakih par dana pogledate malo po lokalnim (a i udaljenim granama) i provjerite one koje više ne koristite.

Ukoliko nismo sigurni je li nam u nekoj grani ostala možda još kakva izmjena koju treba vratiti u \verb+master+, postupak je sljedeći:

\gitoutputcommand{git checkout neka-grana\\git merge master}

\dots{}da bismo preuzeli sve izmjene iz master, tako da stanje bude ažurno.
I sad\dots

\gitoutputcommand{git diff master}

\dots{}da bismo provjerili koje su točno izmjene ostale.
Ako je prazno -- nema razlika i možemo brisati.
Ako nije -- \textbf{ima} izmjena i sad se sami odlučite jesu li te izmjene nešto važno što ćete nastaviti razvijati ili nešto što možemo zanemariti i obrisati tu granu.

\section*{Git gc}
\addcontentsline{toc}{section}{Git gc}

Druga stvar koju se preporuča ima veze s onim našim \verb+.git/objects+ direktorijem kojeg smo spominjali u "Ispod haube" poglavlju.
Kao što znamo, svaki \emph{commit} ima svoju referencu i svoj objekt (datoteku) u tom direktoriju.
Kad napravimo \verb+git commit --amend+ -- git stvara \textbf{novi} \emph{commit}.
Nije da on samo izmijeni stari\footnote{Ne bi ni mogao izmijeniti stari, jer ima drukčiji sadržaj i SHA1 bi mu se nužno morao promijeniti.}.

Grafički:

\input{graphs/amend}

Dakle, git interno dodaje \textbf{novi} objekt (\emph{f'}) i na njega pomiče referencu \verb+HEAD+ (koja je do tada gledala na \emph f).
On samo "kaže": Od sada na dalje, zadnji \emph{commit} u ovoj grani više nije \emph f, nego \emph{f'}.

No, sad u git repozitoriju imamo i \emph{commit} \emph f, a i \emph{f'}, ali samo jedan od njih se koristi (\emph{f'}).
Commit \emph f je \textbf{i dalje snimljen u} \verb+.git/object+ \textbf{direktoriju}.
I on se više neće koristiti.
Puno tih \verb+git commit --amend+ posljedično ostavlja puno takvog "smeća" u repozitoriju.

To vrijedi i za neke druge operacije kao brisanje grana ili rebase.
Git to čini da bi tekuće operacije bilo što je brže moguće.
Čišćenje takvog smeća (\emph{garbage collection} iliti \emph{gc}) ostavlja za kasnije, a ta radnja nije automatizirana nego se od nas očekuje da ju izvršimo\footnote{Nije automatizirana, ali možemo uvijek sami napraviti neki task koji se izvršava na dnevnoj ili tjednoj bazi, a koji "čisti" sve naše git repozitorije.}.

Naredba je \verb+git gc+:

\input{git_output/git_gc}

\dots{}i nju treba izvršavati s vremena na vrijeme.

Osim \verb+gc+, postoji još nekoliko sličnih naredbi kao \verb+git repack+, \verb+git prune+, no one su manje važne za početnika.
Ako vas zanima -- \verb+git help+ je uvijek na dohvat ruke.

\section*{Povijest i brisanje grana}
\addcontentsline{toc}{section}{Povijest i brisanje grane}

Spomenuti ćemo još jednu stvar koja bi logički pripadala u poglavlja o granama i povijesti, ali tada nismo imali dovoljno znanja da bi ju shvatili.

Što se dešava s \emph{commit}ovima iz neke grane nakon što ju obrišemo?
Uzmimo tri primjera.
U sva tri imamo dvije grane: \verb+master+ i \verb+grana+.

Prvi primjer:

\input{graphs/git_merge_i_brisanje_grana_1}

\textbf{Svi čvorovi koji su dio povijesti projekta će ostati u repozitoriju i neće brisati} s \verb+git gc+.
Kako znamo koji čvorovi su dio projekta?
Po tome što imaju neku referencu na sebe.
Ta referenca može biti ili grana ili neki drugi čvor.

Podsjetimo se da su strelice redosljed nastajanja, ali reference idu suprotnim smjerom -- sljedbenik ima referencu na prethodnika.
Dakle, $g$ ima referencu na $f$, $f$ na $e$, itd.
Što je sa čvorom $g$? 
Izgleda kao da nitko nema referencu na njega, ali to nije točno -- grana \verb+grana+ je referenca na njega.

Ako obrišemo granu \verb+grana+ -- $g$ više nema nikoga da njega referencira.
Teorijski bi ga mogli obrisati, ali onda bi mogli obrisati i $f$, $e$ i $d$ ($b$ ne možemo, jer $c$ ima referencu na njega).

Dakle, kad obrišemo granu koja nije \emph{merge}ana u neku drugu granu, onda se svi njeni čvorovi gube iz povijesti projekta.
I, prije ili kasnije će biti obrisatni s \verb+git gc+.

Drugi primjer:

\input{graphs/git_merge_i_brisanje_grana_2}

Ovaj primjer je isti kao i prvi, s jednom razlikom. 
Došlo je do \emph{merge}a.

Znamo da grana nije ništa drugo nego referenca na njen zadnji čvor/\emph{commit}.
Obrišemo li granu \verb+grana+, obrisali smo referencu na njen zadnji čvor $g$.
No, i dalje imamo $q$ koji pokazuje na $g$.
Zbog toga će svi čvorovi grane \verb+grana+ nakon njenog brisanja ostati u repozitoriju.

Treći primjer:

\input{graphs/git_merge_i_brisanje_grana_3}

Ukoliko u ovom promjeru obrišemo \verb+grana+, postoji samo jedan njen čvor koji će biti zagubljen -- $g$.
$z$ ima referencu na $f$, a s $f$ nam garantira da i $e$ i $d$ ostaju dio povijesti projekta.

\section*{\emph{Squash merge} i brisanje grana}
\addcontentsline{toc}{section}{\emph{Squash merge} i brisanje grana}

Uzmimo opet:

\input{graphs/git_merge_i_brisanje_grana_4}

Želimo li u povijesti projekta sačuvati izmjene iz neke grane, ali ne i njenu povijest -- to se može s \verb+git merge --squash+.
Podsjetimo se -- tom operacijom git \textbf{hoće} preuzeti izmjene iz grane, ali \textbf{neće} u čvoru $q$ napraviti referencu na $g$.
Dakle, rezultat je kao da kod klasičnog \emph{merge}a, ali bez reference (u prethodnom grafu crvenom bojom):

\input{graphs/git_merge_i_brisanje_grana_5}

Sad smo preuzeli izmjene iz \verb+grana+ u \verb+master+, ali \verb+git gc+ će prije ili kasnije obrisati $d$, $e$, $f$ i $g$.

S \verb+git merge --squash+ cijelu granu svodimo na jedan \emph{commit} i kasnije gubimo njenu povijest\footnote{\dots{}barem ako ju kasnije ne \emph{merge}amo klasičnim putem.}.
