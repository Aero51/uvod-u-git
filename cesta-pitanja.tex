\tocChapter{Česta pitanja}

Jedno je razumijeti naredbe i terminologiju gita, a potpuno drugo je imati iskustvo u radu s gitom.
Da bi nekako došli do iskustva, trebamo imati osjećaj o tome koji su problemi koji se pojavljuju u radu i trebamo automatizirati postupak njihovog riješavanja.
U ovom poglavlju ćemo proći nekoliko takvih "situacija".

\tocSection{Jesmo li $push$ali svoje izmjene na udaljeni repozitorij?}

S klasičnim sustavima za verzioniranje, kod kojeg smo izmijenili može biti ili lokalno ne$commit$an ili $commit$an na centralnom repozitoriju.

Kao što sad već znamo, s gitom je stvar za nijansu složenija.
Naš kod može biti lokalno ne$commit$an, može biti $commit$an na našem lokalnom repozitoriju, a može biti i $push$an na udaljeni repozitorij.
Više puta mi se desilo da se kolega (koji tek uči git) pita "Kako to da moje izmjene nisu završile na produkciji\footnote{\dots{}ili produkcijskom $build$u.}, \textbf{iako sam ih $commit$ao}?".
Odgovor je jednostavan -- $commit$ao ih je lokalno, ali nije $push$ao na naš glavni repozitorij.

Problem kojeg on ima je u tome što nije nigdje jasno vidljivo jesu li izmjene iz njegove \verb+master+ grane $push$ane na udaljeni repozitorij.

Jedan jednostavan način da to provjerite je da provjerite odnos između \verb+master+ i \verb+origin/master+.
Za svaki slučaj, prvo ćemo osvježiti stanje udaljenog repozitorija s:

\gitoutput{git fetch}

\dots{}i sad idemo \textbf{vizualno} proučiti odnos između naše dvije grane:

\gitoutput{gitk master origin/master}

Sad pogledajte na grafu je li:
\begin{itemize}
    \item \verb+master+ \textbf{ispred} \verb+origin/master+, u tom slučaju vi imate više $commit$ova od udaljenog repozitorija i možete ih $push$ati,
    \item \verb+master+ \textbf{iza} \verb+origin/master+, u tom slučaju vi imate manje $commit$ova od udaljenog repozitorija i trebate ih pokupiti s udaljenog repozitorija ($pull$ ili $rebase$),
    \item \verb+master+ i \verb+origin/master+ se nalaze na dvije grane koje su međusobno divergirale (u tom slučaju vi \textbf{imate} ne$commit$ane izmjene, ali trebate prvo napraviti $pull$ i onda ih $push$ati).
\end{itemize}

Primjer situacije gdje nemamo ništa za $push$ati na na udaljeni repozitorij (nego čak imamo nešto za \textbf{preuzeti} iz njega):

\gitgraphics{images/origin_master_ispred_master.png}{5cm}

Primjer gdje imamo dva $commit$a koje nismo $push$ali, a mogli bismo:

\gitgraphics{images/master_ispred_origin_master.png}{5cm}

Primjer gdje imamo tri $commit$a za $push$anje, ali trebamo prije toga preuzeti četiri $commit$a it \verb+origin/master+ i $merge$ati ih u našu granu:

\gitgraphics{images/master_i_origin_master_divergirani.png}{5cm}

I, situacija u kojoj je lokalni \verb+master+ potpuno isti kao udaljeni \verb+origin/master+:

\gitgraphics{images/master_i_origin_master_isti.png}{6.5cm}

\tocSection{$Commit$ali smo u krivu granu}

Na primjer, slučajno smo commitali u \verb+master+, a trebali smo u \verb+unicode-fix+.
Pretpostavimo da su zadnja dva $commit$a iz \verb+master+ ona koja želimo prebaciti u ovu drugu granu.

Riješenje je jednostavno, prvo ćemo se prebaciti u tu drugu granu:

\gitoutput{git checkout unicode-fix}

Zatim chemo preuzeti jedan po jedan ta dva $commit$a u trenutnu granu:

\gitoutput{git cherry-pick master\\
git cherry-pick master\textasciitilde{}1}

Podsjetimo se da je \verb+master+ naziv grane, ali i pokazivač na njegov zadnji $commit$, tako da \verb+git cherry-pick master+ preuzima samo taj zadnji $commit$.
Commit \verb+master~1+ se odnosi na pretposljednji u toj grani.

Umjesto \verb+master+ i \verb+master~1+ smo mogli koristiti i SHA1 identifikatora $commit$ova, koje možemo dobiti s \verb+git log master+.

Sad, kad smo te $commit$ove prebicili (i) u željenu granu, trebamo ih maknuti iz one u kojoj su neželjeni.
Idemo se prvo prebaciti na nju:

\gitoutput{git checkout master}

I, idemo ih obrisati:

\gitoutput{git reset --hard master~2}

\dots{}što tu granu prebacuje na stanje u \verb+master~2+ (a to je pred-predzadnji $commit$).

\tocSection{$Commit$ali smo u granu X, ali te commitove želimo prebaciti u novu granu}

$Commit$ali smo u \verb+master+, ali u jednom trenutku smo zaključili da te izmjene ne želimo tu.
Želimo stvoriti novu granu koja će nam sačuvati te $commit$ove, a \verb+master+ resetirati na isto stanje kao i u udaljenom repozitoriju.
Pa, idemo redom, s\dots

\gitoutput{git checkout -b nova-grana}

\dots{}ćemo kreirati novu granu iz \verb+master+.
Te dvije grane su trenutno potpuno iste, dakle, upravo smo riješili prvi dio zadatka -- sačuvali smo $commit$ove iz \verb+master+ u drugoj grani.

S obzirom da nam stanje u \verb+master+ treba biti isto kao u \verb+origin/master+, prvo ćemo se potruditi da lokalno imamo ažurno stanje udaljenog repozitorija:

\gitoutput{git fetch}

\dots{}i sad idemo izjednačiti \verb+master+ i \verb+origin/master+:

\gitoutput{git reset --hard origin/master}

\tocSection{Imamo ne$commitane$ izmjene i git nam ne da prebacivanje na drugu granu}

Imamo li ne$commit$anih izmjena, git ponekad neće dati prebacivanje ($checkout$anje) s grane na granu.
Ukoliko te izmjene predstavljaju neku logičnu cjelinu -- onda ćemo ih jednostavno $commit$ati i to nije problem.
No, ako se nalazimo na pola posla i to ne želimo\dots

To se može zaobići na dva načina.
Jedan je da koristite naredbu \verb+git stash+, a drugi je da ipak -- $commit$ate.
Problem s ovim drugim pristupom je što ćete imati djelomični $commit$ s poluzavršenim kodom.  
Međutim, kad se naknadno vratimo na ovu granu (nakon što obavimo posao na nekoj drugoj) -- možemo posao završiti i commitati ga s:

\gitoutput{git commit --amend -m "Novi komentar...}

I, osvježili smo prethodni polovični $commit$.
Ukoliko to činimo, treba samo pripaziti da svoj "privremeni" $commit$ ne $push$ate na udaljeni repozitorij dok nije gotov\footnote{To općenito vrijedi za $commit$ove, nemojte koristiti "commit --amend" ukoliko ste već $push$ali na udaljeni repozitorij.}.

\tocSection{Zadnjih $n$ $commit$ova treba "stisnuti" u jedan $commit$}

\TODO

\tocSection{$Push$ali smo u remote repozitorij izmjenu koju nismo htjeli}

\TODO

